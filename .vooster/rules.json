{
  "rules": [
    {
      "type": "prd",
      "content": "# 제품 요구사항 문서(PRD)\n\n## 1. 개요\n초등학생(1~6학년)의 ADHD 조기 선별 및 집중력·충동성 완화를 돕는 웹 기반 PWA 게임 플랫폼. 3분 내외 미니게임과 학령별 자가진단 테스트를 제공해 가정·학교 어디서나 사용 가능하도록 한다.\n\n## 2. 문제 정의\n- ADHD 증상은 조기 발견이 어렵고 치료 접근성이 낮다.  \n- 전통적인 검사·훈련은 지루해 참여율이 낮다.  \n- 보호자·교사는 아이의 주의집중 데이터를 객관적으로 확인하기 어렵다.\n\n## 3. 목표 및 지표\n- 1차 목표: 학령별 ADHD 스크리닝 + 게임 기반 인지 훈련 제공\n- 2차 목표: 데이터 기반 맞춤 피드백, 보호자·교사 지원\n- 성공 지표  \n  - 월간 활성 사용자(MAU) 10,000명  \n  - 스크리닝 완료율 60% 이상  \n  - 4주 연속 게임 참여 아동 중 30% 이상 집중력 지표 개선  \n  - 재방문률 50% 이상\n\n## 4. 타깃 사용자\n### 주요 사용자\n- 초등 저학년(1~3): 보호자/교사 도움 하에 사용, 난이도 낮음\n- 초등 고학년(4~6): 자기주도 사용, 난이도 중간  \n### 2차 사용자\n- 부모·보호자: 결과 모니터링, 개입 시점 판단\n- 담임·상담 교사: 학급 활용, 다수 학생 데이터 확인\n- 소아정신과·치료사(향후): 데이터 참고\n\n## 5. 사용자 스토리\n- “저학년 보호자로서, 아이가 산만해 보여 자가진단을 해보고 싶다.”  \n- “고학년 학생으로서, 재밌는 게임을 하며 집중력을 높이고 싶다.”  \n- “교사로서, 학급 전체의 집중력 게임 결과를 수업계획에 활용하고 싶다.”\n\n## 6. 기능 요구사항\n### 핵심 기능\n1. ADHD 스크리닝 테스트  \n   - 저학년용(쉬운 문항+음성 안내), 고학년용(텍스트 중심)  \n   - 18문항, 자동 채점, 결과 해석·권고 표시  \n   - 결과 이력 저장·그래프 제공  \n\n2. 3분 미니게임 모듈  \n   - 지속주의(CPT형), 충동 억제(GO/NO-GO), 작업기억(순서 기억) 등 5종  \n   - AI 난이도 조절(적응형)  \n   - 즉각 피드백·포인트 부여  \n\n3. 데이터 대시보드  \n   - 아동별 점수/반응속도/오답 횟수 그래프  \n   - 영역별(집중·기억·충동) 레이더 차트  \n   - 또래 평균 비교(익명 집계)  \n\n4. 계정·프로필  \n   - 이메일·소셜 로그인, 보호자 계정에 다중 아동 프로필  \n   - 교사 계정: 학생 코드로 일괄 등록  \n\n5. 보상 시스템  \n   - 코인·배지, 아바타 꾸미기샵  \n   - 연속 플레이·기록 갱신 보상, 리더보드 미제공  \n\n6. 콘텐츠 업데이트 프레임워크  \n   - 게임 모듈 플러그인 방식 배포  \n   - 신규 콘텐츠 알림/튜토리얼 자동 노출  \n\n### 지원 기능\n- 오프라인 모드(캐시)  \n- 푸시 알림(플레이 리마인더)  \n- 다국어(한국어 우선, 향후 영어 추가)  \n\n## 7. 비기능 요구사항\n- 성능: 2초 내 화면 전환, 게임 FPS 30 이상  \n- 보안: OAuth2, JWT, 개인정보 암호화 저장, COPPA/KISA 준수  \n- 사용성: WCAG 2.1 AA, 폰트 최소 16px  \n- 확장성: 10만 DAU까지 서버 무중단 스케일  \n- 호환성: 크롬·사파리·엣지 최신, iOS/Android PWA 설치\n\n## 8. 기술 고려\n- 프론트엔드: Next.js + React 18, TypeScript, Service Worker  \n- 백엔드: Supabase(PostgreSQL, Auth, Storage)  \n- 데이터: 사용자·게임 로그 테이블, 익명 통계 뷰  \n- 분석: Supabase Edge Functions + Python ML 모델(향후)  \n- 통합: Firebase Cloud Messaging, Sentry, Amplitude\n\n## 9. 성공 지표 세부\n- 기술: 오류율 <1%, P95 응답 300ms  \n- 비즈니스: 결제 없이 광고/제휴 매출 월 30M KRW (Phase 3)  \n- 사용자: 일평균 게임 2회 이상 비율 40%  \n\n## 10. 일정 및 마일스톤\n- Phase 1 MVP (0~3개월)  \n  - 핵심 게임 3종, 스크리닝, 기본 대시보드  \n- Phase 2 확장 (4~6개월)  \n  - 게임 5종, 난이도 적응, 보상·샵, 교사 모드  \n- Phase 3 고도화 (7~12개월)  \n  - ML 기반 맞춤 추천, 멀티 플레이 협동 게임, 수익 모델 탑재\n\n## 11. 위험 및 대응\n- 임상 효과 불확실 → 대학병원 IRB 협력, 파일럿 연구 진행  \n- 과몰입·중독 우려 → 세션 20분 제한, 휴식 알림  \n- 개인정보 보호 → 최소 수집, 익명화, 주기적 보안 감사  \n- 콘텐츠 신선도 저하 → 월 1회 신규 게임 릴리스 로드맵\n\n## 12. 향후 계획\n- AI 기반 ADHD 위험 예측 점수 제공  \n- 음성·모션 센서 활용 신체 활동 게임 추가  \n- 의료기관 연동(FHIR API)으로 진료 연계  \n- 해외 시장(영어·일본어) 진출 및 글로벌 데이터셋 확보",
      "writedAt": "2025-07-18T00:47:30.003Z"
    },
    {
      "type": "architecture",
      "content": "# Technical Requirements Document (TRD)\n\n## 1. Executive Technical Summary\n- **프로젝트 개요**  \n  초등학생 대상 ADHD 조기 선별 및 인지 훈련 웹 기반 PWA 플랫폼. Next.js 기반 프론트엔드와 Supabase 백엔드를 활용해 최소한의 기술 스택으로 빠른 출시 및 안정적 운영을 목표로 함.\n- **핵심 기술 스택**  \n  Next.js, React 18, TypeScript, Service Worker, Supabase(PostgreSQL, Auth, Storage), Firebase Cloud Messaging, Sentry, Amplitude\n- **주요 기술 목표**  \n  • 화면 전환 2초 이내, 게임 FPS ≥ 30  \n  • P95 API 응답 300ms 이하  \n  • DAU 10만까지 무중단 확장  \n- **중요 기술 가정**  \n  • Supabase 서버리스 확장성으로 DAU 확장 수용 가능  \n  • PWA 지원 브라우저(iOS/Android)에 Service Worker 호환  \n  • AI 난이도 조절은 향후 Edge Functions로 분리 구현  \n\n## 2. Tech Stack\n\n| Category            | Technology / Library               | Reasoning                                            |\n| ------------------- | ---------------------------------- | ---------------------------------------------------- |\n| Frontend 프레임워크 | Next.js                            | SSR/SSG 지원, PWA 최적화, 빠른 초기 로딩             |\n| UI 라이브러리       | React 18, TypeScript               | 컴포넌트 재사용성, 타입 안정성                       |\n| PWA 지원            | Service Worker                     | 오프라인 캐시, 푸시 알림 구현 지원                  |\n| 스타일링            | CSS Modules / Tailwind CSS (선택)  | 모듈화된 스타일, 생산성 증대                         |\n| 백엔드              | Supabase (PostgreSQL, Auth, Storage) | 완전 관리형 데이터베이스·인증·스토리지              |\n| API                 | Next.js API Routes + Supabase Client | 단일 코드베이스, 경량 API 구현                       |\n| 실시간/푸시         | Firebase Cloud Messaging           | 푸시 알림 구현 표준, 크로스 플랫폼 지원             |\n| 분석/모니터링       | Amplitude                          | 사용자 행동 분석, 성공 지표 추적                     |\n| 오류 모니터링       | Sentry                             | 클라이언트·서버 에러 추적                            |\n| CI/CD               | GitHub Actions                     | 코드 품질 검사, 배포 자동화                          |\n| 호스팅              | Vercel (프론트엔드), Supabase      | 글로벌 CDN, 무중단 배포, 서버리스 스케일링           |\n\n## 3. System Architecture Design\n\n### Top-Level Building Blocks\n- Frontend PWA  \n  • Next.js 기반 UI/UX, Service Worker 캐시, 푸시 알림 리스너  \n- Backend API  \n  • Next.js API Routes + Supabase Client, 인증(JWT), 권한 체크  \n- Database & Storage  \n  • Supabase PostgreSQL: 사용자·게임 로그·결과 이력  \n  • Supabase Storage: 게임 리소스·탈것 이미지  \n- Edge Functions / ML 모듈  \n  • 향후 난이도 적응·예측 모델을 위한 Supabase Edge Functions + Python  \n- Third-Party Services  \n  • Firebase Cloud Messaging, Sentry, Amplitude\n\n### Top-Level Component Interaction Diagram\n```mermaid\ngraph TD\n    A[User(PWA)] -->|HTTP/WS| B[Next.js Frontend]\n    B -->|REST| C[Next.js API Routes]\n    C -->|SQL| D[Supabase PostgreSQL]\n    C -->|Storage| E[Supabase Storage]\n    C -->|Invoke| F[Supabase Edge Functions]\n    F -->|ML| G[Python Model]\n    B -->|Push| H[FCM]\n    B -->|Log| I[Amplitude]\n    B -->|Error| J[Sentry]\n```\n- 사용자가 PWA를 통해 UI 이벤트 발생  \n- Frontend가 API Routes 호출 및 실시간 WebSocket/푸시 수신  \n- API Routes는 Supabase DB/Storage 조작 및 Edge Functions 트리거  \n- Edge Functions에서 Python ML 모델 연동  \n- 사용자 행동은 Amplitude로, 에러는 Sentry로 로깅  \n\n### Code Organization & Convention\n\n**Domain-Driven Organization Strategy**  \n- 도메인별 분리: screening, game, dashboard, account, reward, common  \n- 레이어 분리: presentation, service, repository, infrastructure  \n- 기능 단위 모듈: 각 게임 모듈별 플러그인 방식  \n- 공유 컴포넌트: UI, 타입 정의, 유틸리티 모듈\n\n**Universal File & Folder Structure**\n```\n/\n├── public\n│   └── assets             # 정적 리소스\n├── src\n│   ├── common             # 공통 유틸/타입/컴포넌트\n│   ├── components         # UI 컴포넌트\n│   ├── pages              # Next.js 페이지\n│   ├── services           # 비즈니스 로직 서비스\n│   ├── repositories       # DB/Storage 접근 계층\n│   ├── domain\n│   │   ├── screening      # 스크리닝 테스트\n│   │   ├── game           # 미니게임 모듈\n│   │   ├── dashboard      # 대시보드\n│   │   ├── account        # 계정/프로필\n│   │   └── reward         # 보상 시스템\n│   ├── hooks              # React 커스텀 훅\n│   ├── styles             # 글로벌 스타일/Tailwind 설정\n│   └── pages\n│       ├── api            # Next.js API Routes\n│       └── _app.tsx\n├── .github                # CI/CD 워크플로\n└── next.config.js         # Next.js 설정\n```\n\n### Data Flow & Communication Patterns\n- **Client-Server Communication**: RESTful API + WebSocket (게임 실시간 업데이트)  \n- **Database Interaction**: Supabase JS Client + SQL query, 트랜잭션 관리  \n- **External Service Integration**: FCM HTTPv1 API, Sentry SDK, Amplitude SDK  \n- **Real-time Communication**: Service Worker Push, 게임 이벤트 WebSocket  \n- **Data Synchronization**: IndexedDB 캐시 후 온라인 시 동기화\n\n## 4. Performance & Optimization Strategy\n- 코드 스플리팅 및 SSG/ISR 활용으로 초기 로딩 최적화  \n- Service Worker 캐싱 전략으로 오프라인 경험 및 네트워크 비용 절감  \n- DB 인덱스 최적화, 쿼리 캐싱 및 Supabase Connection Pool 관리  \n- 이미지·리소스 WebP 변환 및 CDN 활용  \n\n## 5. Implementation Roadmap & Milestones\n\n### Phase 1: Foundation (MVP 구현, 0~3개월)\n- Core Infrastructure: Next.js 프로젝트 및 Supabase 세팅  \n- Essential Features: 스크리닝 테스트(저학년·고학년), 3종 미니게임  \n- Basic Security: OAuth2·JWT 인증, 개인정보 암호화 저장  \n- Development Setup: GitHub Actions CI/CD 파이프라인  \n- Timeline: 12주\n\n### Phase 2: Feature Enhancement (4~6개월)\n- Advanced Features: 게임 5종 완성, AI 난이도 적응 로직  \n- Performance Optimization: DB 인덱스·캐시 전략 개선  \n- Enhanced Security: COPPA/KISA 준수 감사, 보안 점검  \n- Monitoring Implementation: Sentry·Amplitude 대시보드 완비  \n- Timeline: 12주\n\n### Phase 3: Scaling & Optimization (7~12개월)\n- Scalability Implementation: 서버리스 확장 정책, Auto-Scaling 설정  \n- Advanced Integrations: 교사용 대시보드, ML 기반 맞춤 추천  \n- Enterprise Features: FHIR API 연동, 글로벌 다국어 지원  \n- Compliance & Auditing: 정기 보안 감사, IRB 협력 연구 결과 반영  \n- Timeline: 24주\n\n## 6. Risk Assessment & Mitigation Strategies\n\n### Technical Risk Analysis\n- 기술 위험: Supabase 확장 한계 → 사전 부하 테스트, 파티셔닝 설계  \n- 성능 위험: P95 응답 지연 → 캐시·CDN, API Rate Limit 모니터링  \n- 보안 위험: JWT 탈취·XSS → HTTPS, CSP, HttpOnly 쿠키 적용  \n- 통합 위험: FCM·External API 장애 → 재시도 로직, Circuit Breaker 패턴  \n- Mitigation Strategies: 자동화된 부하·보안 테스트, 장애 전파 알림 체계 구축  \n\n### Project Delivery Risks\n- 일정 위험: 기능 지연 → 스코프 우선순위 조정, 스프린트 단위 리뷰  \n- 자원 위험: 전문인력 부족 → 외부 컨설팅, 크로스 트레이닝  \n- 품질 위험: 테스트 커버리지 부족 → 자동화 테스트(유닛·E2E) 필수화  \n- 배포 위험: 환경 불일치 → IaC(Terraform)로 인프라 관리, 스테이징 프로세스  \n- Contingency Plans: 기능 분할 배포(Feature Flag), 외부 BaaS 대체 옵션 검토  \n\n---  \n**끝**",
      "writedAt": "2025-07-18T00:47:30.003Z"
    },
    {
      "type": "step-by-step",
      "content": "\n## Core Directive\nYou are a senior software engineer AI assistant. For EVERY task request, you MUST follow the three-phase process below in exact order. Each phase must be completed with expert-level precision and detail.\n\n## Guiding Principles\n- **Minimalistic Approach**: Implement high-quality, clean solutions while avoiding unnecessary complexity\n- **Expert-Level Standards**: Every output must meet professional software engineering standards\n- **Concrete Results**: Provide specific, actionable details at each step\n\n---\n\n## Phase 1: Codebase Exploration & Analysis\n**REQUIRED ACTIONS:**\n1. **Systematic File Discovery**\n   - List ALL potentially relevant files, directories, and modules\n   - Search for related keywords, functions, classes, and patterns\n   - Examine each identified file thoroughly\n\n2. **Convention & Style Analysis**\n   - Document coding conventions (naming, formatting, architecture patterns)\n   - Identify existing code style guidelines\n   - Note framework/library usage patterns\n   - Catalog error handling approaches\n\n**OUTPUT FORMAT:**\n```\n### Codebase Analysis Results\n**Relevant Files Found:**\n- [file_path]: [brief description of relevance]\n\n**Code Conventions Identified:**\n- Naming: [convention details]\n- Architecture: [pattern details]\n- Styling: [format details]\n\n**Key Dependencies & Patterns:**\n- [library/framework]: [usage pattern]\n```\n\n---\n\n## Phase 2: Implementation Planning\n**REQUIRED ACTIONS:**\nBased on Phase 1 findings, create a detailed implementation roadmap.\n\n**OUTPUT FORMAT:**\n```markdown\n## Implementation Plan\n\n### Module: [Module Name]\n**Summary:** [1-2 sentence description of what needs to be implemented]\n\n**Tasks:**\n- [ ] [Specific implementation task]\n- [ ] [Specific implementation task]\n\n**Acceptance Criteria:**\n- [ ] [Measurable success criterion]\n- [ ] [Measurable success criterion]\n- [ ] [Performance/quality requirement]\n\n### Module: [Next Module Name]\n[Repeat structure above]\n```\n\n---\n\n## Phase 3: Implementation Execution\n**REQUIRED ACTIONS:**\n1. Implement each module following the plan from Phase 2\n2. Verify ALL acceptance criteria are met before proceeding\n3. Ensure code adheres to conventions identified in Phase 1\n\n**QUALITY GATES:**\n- [ ] All acceptance criteria validated\n- [ ] Code follows established conventions\n- [ ] Minimalistic approach maintained\n- [ ] Expert-level implementation standards met\n\n---\n\n## Success Validation\nBefore completing any task, confirm:\n- ✅ All three phases completed sequentially\n- ✅ Each phase output meets specified format requirements\n- ✅ Implementation satisfies all acceptance criteria\n- ✅ Code quality meets professional standards\n\n## Response Structure\nAlways structure your response as:\n1. **Phase 1 Results**: [Codebase analysis findings]\n2. **Phase 2 Plan**: [Implementation roadmap]  \n3. **Phase 3 Implementation**: [Actual code with validation]\n",
      "writedAt": "2025-07-18T00:47:30.003Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-18T00:47:30.003Z"
    },
    {
      "type": "git-commit-message",
      "content": "\n# Git Commit Message Rules\n\n## Format Structure\n```\n<type>(<scope>): <description>\n\n[optional body]\n\n[optional footer]\n```\n\n## Types (Required)\n- `feat`\n- `fix`\n- `docs`\n- `style`\n- `refactor`\n- `perf`\n- `test`\n- `chore`\n- `ci`\n- `build`\n- `revert`\n\n## Scope (Optional)\n- Component, file, or feature area affected\n- Use kebab-case: `user-auth`, `payment-api`\n- Omit if change affects multiple areas\n\n## Description Rules\n- Use imperative mood\n- No capitalization of first letter\n- No period at end\n- Max 50 characters\n- Be specific and actionable\n\n## Body Guidelines\n- Wrap at 72 characters\n- Explain what and why, not how\n- Separate from description with blank line\n- Use bullet points for multiple changes\n\n## Footer Format\n- `BREAKING CHANGE:` for breaking changes\n- `Closes #123` for issue references\n- `Co-authored-by: Vooster AI (@vooster-ai)`\n\n## Examples\n```\nfeat(auth): add OAuth2 Google login\n\nfix: resolve memory leak in user session cleanup\n\ndocs(api): update authentication endpoints\n\nrefactor(utils): extract validation helpers to separate module\n\nBREAKING CHANGE: remove deprecated getUserData() method\n```\n\n## Workflow Integration\n**ALWAYS write a commit message after completing any development task, feature, or bug fix.**\n\n## Validation Checklist\n- [ ] Type is from approved list\n- [ ] Description under 50 chars\n- [ ] Imperative mood used\n- [ ] No trailing period\n- [ ] Meaningful and clear context\n    ",
      "writedAt": "2025-07-18T00:47:30.003Z"
    }
  ]
}